#include "pcol_iterative.h"
#include <iostream>
#include <sstream>
#include <string>
#include "h_time.h"
#include "ply_stream.h"

using std::ostringstream;
using std::endl;


PairCollapse::PairCollapse() {
	info_buf_len = 0;
	INFO_BUF[0] = '\0';
	faceIndexComp.setFaces(&faces);
}

PairCollapse::~PairCollapse() {
	cvert.adjacent_col_pairs.setNULL();
	cvert.adjacent_faces.setNULL();
}

void PairCollapse::allocVerts(uint _vert_count) {
	vertices.resize(_vert_count);
}

void PairCollapse::allocFaces(uint _face_count) {
	faces.resize(_face_count);
}

void PairCollapse::addVertex(HVertex vert) {
	cvert.Set(vert.x, vert.y, vert.z);
	// set the new id, this is important!!
	cvert.setNewId(INVALID_VERT);
	vertices.push_back(cvert);
	vertices[vertices.count() - 1].allocAdjacents(DFLT_STAR_FACES, DFLT_STAR_PAIRS);
}

bool PairCollapse::addFace(HFace face) {

	cface.set(face.i, face.j, face.k);

	if (!cface.valid()) {
		addInfo("#ERROR: duplicate verts in input face\n");
		return false;
	}
	if (!cface.indicesInRange(0, vertices.count() - 1)) {
		addInfo("#ERROR: vertex out of range in input face\n");
		return false;
	}

	faces.push_back(cface);

	// add the face index to the vertices
	vertices[face.i].adjacent_faces.push_back(faces.count() - 1);
	vertices[face.j].adjacent_faces.push_back(faces.count() - 1);
	vertices[face.k].adjacent_faces.push_back(faces.count() - 1);

	// set the new_id field
	vertices[face.i].setNewId(face.i);
	vertices[face.j].setNewId(face.j);
	vertices[face.k].setNewId(face.k);

	return true;
}

void PairCollapse::intialize() {

	valid_verts = vertices.count();
	valid_faces = faces.count();
	unreferVertsCheck();
	collectPairs();
}

void PairCollapse::collapsePair(pCollapsablePair &pair) {

	uint vert1 = pair->vert1, vert2 = pair->vert2;

	// set the new_id field and new_vertex field in order 
	// to invalidate vert2 and maintain the collapse footprint
	vertices[vert2].setNewId(vert1);
	//vertices[pair->vert2].new_vertex.Set(pair->new_vertex);
	// vert1 will be the collapsed vertex, set to the new position
	vertices[vert1].Set(pair->new_vertex);
	valid_verts --;

	mergePairs(vert1, vert2);
	mergeFaces(vert1, vert2);
}

bool PairCollapse::targetVert(uint targe_count) {

	return true;
}

bool PairCollapse::targetFace(uint target_count) {
	
	CollapsablePair* top_pair;

	HTime htime;

	while(valid_faces > target_count) {

		top_pair = (CollapsablePair *)pair_heap.extract();
		collapsePair(top_pair);
	}

	htime.setEndPoint();
	ostringstream ostr;

	ostr << "\tmodel simplified" << endl
		<< "\tverts:\t" << valid_verts << "\tfaces:\t" << valid_faces << endl
		<< "\ttime consuming:\t" << htime.printElapseSec() << endl << endl;

	addInfo(ostr.str().c_str());

	return true;
}

bool PairCollapse::readPly(char* filename) {

	PlyStream plyStream;
	int i;
	HVertex v;
	HFace f;
	HTime htime;

	if (!plyStream.openForRead(filename)) {

		ostringstream oss;
		oss << "\t#ERROR: open file " << filename << " failed" << endl;
		addInfo(oss.str().c_str());
		return false;
	}

	this->allocVerts(plyStream.getVertexCount());
	this->allocFaces(plyStream.getFaceCount());

	cvert.adjacent_col_pairs.setNULL();
	cvert.adjacent_faces.setNULL();

	for (i = 0; i < plyStream.getVertexCount(); i ++) {

		if (!plyStream.nextVertex(v)) 
			return false;
		addVertex(v);
	}

	for (i = 0; i < plyStream.getFaceCount(); i ++) {

		if (!plyStream.nextFace(f)) 
			return false;
		addFace(f);
	}

	intialize();

	htime.setEndPoint();
	ostringstream ostr;

	ostr << "\tread complete" << endl
		<< "\tfile name:\t" << filename << endl
		<< "\treferred verts:\t" << valid_verts << "\tfaces:\t" << plyStream.getFaceCount() << endl
		<< "\tread time:\t" << htime.getElapseStr() << endl << endl;

	addInfo(ostr.str().c_str());

	return true;
}

bool PairCollapse::writePly(char* filename) {

	ofstream fout(filename);
	if (fout.bad())
		return false;
	HTime htime;

	/* write head */
	fout << "ply" << endl;
	fout << "format ascii 1.0" << endl;
	fout << "comment generated by ht pair collapse" << endl;

	fout << "element vertex " << valid_verts << endl;
	fout << "property float x" << endl;
	fout << "property float y" << endl;
	fout << "property float z" << endl;
	fout << "element face " << valid_faces << endl;
	fout << "property list uchar int vertex_indices" << endl;
	fout << "end_header" << endl;

	int i;
	valid_vert_count = 0;
	for (i = 0; i < vertices.count(); i ++)
		if (vertices[i].valid(i)) {
			fout << vertices[i].x << " " << vertices[i].y << " " << vertices[i].z << endl;
			vertices[i].output_id = valid_vert_count;
			valid_vert_count ++;
		}

	int valid_face_count = 0;
	for (i = 0; i < faces.count(); i ++) 
		if (faces[i].valid()) {
			fout << "3 " << vertices[faces[i].i].output_id << " "
				<< vertices[faces[i].j].output_id << " "
				<< vertices[faces[i].k].output_id << endl;
			valid_face_count ++;
		}

	htime.setEndPoint();

	// statistics
	htime.setEndPoint();
	ostringstream ostr;

	ostr << "\tsimplified mesh written" << endl
		<< "\tfile name:\t" << filename << endl
		//<< "\tverts:\t" << valid_vert_count << "\tfaces:\t" << valid_face_count << endl
		<< "\twrite time:\t" << htime.getElapseStr() << endl << endl;

	addInfo(ostr.str().c_str());

	return true;
}

void PairCollapse::outputIds(char* filename) {

	ofstream fout(filename);

	fout << "id\tnew_id\tout_put" << endl;

	for (int i = 0; i < vertices.count(); i ++) {
		fout << i << "\t" << vertices[i].new_id << "\t" << vertices[i].output_id << endl;
	}
}

void PairCollapse::generateOutputId() {

	valid_vert_count = 0;

	for (int i = 0; i < vertices.count(); i ++)
		if (vertices[i].valid(i)) {
			vertices[i].output_id = valid_vert_count;
			valid_vert_count ++;
		}
}

///////////////////////////////////////////////////////////////
// operations other than simplification

void PairCollapse::addInfo(const char *s) {

	int l = strlen(s);
	memcpy(INFO_BUF + info_buf_len, s, l);
	info_buf_len += l;
	INFO_BUF[l] = '\0';
}