#include "grid_patch.h"
#include "os_dependent.h"
#include "h_dynamarray.h"
#include "ecol_iterative_quadric.h"

using std::cerr;
using std::endl;
using std::streampos;


bool HGridPatch::openForWrite(const char* dir_path, const HTriple<uint> grid_index) {

	char vert_name[__FILE_NAME_BUF_SIZE], face_name[__FILE_NAME_BUF_SIZE];
	getPatchPath(dir_path, grid_index, vert_name, face_name);

	if(!HMeshPatch::openForWrite(vert_name, face_name))
		return false;
	return true;
}

bool HGridPatch::openForRead(const char* dir_path, const HTriple<uint> grid_index) {

	char vert_name[__FILE_NAME_BUF_SIZE], face_name[__FILE_NAME_BUF_SIZE];
	getPatchPath(dir_path, grid_index, vert_name, face_name);

	if(!HMeshPatch::openForRead(vert_name, face_name))
		return false;
	return true;
}

bool HGridPatch::patchToPly(const char* dir_path, const HTriple<uint> grid_index) {

	char vert_name[__FILE_NAME_BUF_SIZE], face_name[__FILE_NAME_BUF_SIZE];
	char ply_name[__FILE_NAME_BUF_SIZE];
	int i;
	uint orig_id; // external id
	HVertex v;
	HTriple<uint> f;
	ostringstream oss;

	/* retrieve the names */
	getPatchPath(dir_path, grid_index, vert_name, face_name);
	if (dir_path) 
		oss << dir_path << hPathSeperator();
	oss << grid_index.i << "_" << grid_index.j << "_" << grid_index.k << ".ply";
	stringToCstr(oss.str(), ply_name);

	ofstream fout(ply_name);
	if (fout.bad())
		return false;

	fout << "ply" << endl;
	fout << "format ascii 1.0" << endl;
	fout << "comment generated by patching simp" << endl;

	fout << "element vertex " << vert_count + exterior_count << endl;
	fout << "property float x" << endl;
	fout << "property float y" << endl;
	fout << "property float z" << endl;
	fout << "element face " << face_count << endl;
	fout << "property list uchar int vertex_indices" << endl;
	fout << "end_header" << endl;

	if (!HMeshPatch::openForRead(vert_name, face_name))
		return false;

	for (i = 0; i < vert_count; i ++) {
		if (!nextInteriorVertex(orig_id, v))
			return false;
		id_map[orig_id] = i;
		fout << v.x << " " << v.y << " " << v.z << endl;
	}

	for (i = 0; i < interior_count; i ++) {
		if (!nextInteriorBound(orig_id))
			return false;
	}

	for (i = 0; i < exterior_count; i ++) {
		if (!nextExteriorBound(orig_id, v))
			return false;
		id_map[orig_id] = vert_count + i;
		fout << v.x << " " << v.y << " " << v.z << endl;
	}

	for (i = 0; i < face_count; i ++) {
		if (!nextFace(f))
			return false;
		fout << "3 " << id_map[f.i] << " " << id_map[f.j] << " " << id_map[f.k] << endl;
	}

	closeForRead();
	//id_map.clear();

	return true;
}

bool HGridPatch::pairCollapseToPly(
		char* dir_path, HTriple<uint> grid_index, uint total_verts, uint total_target) {

	QuadricEdgeCollapse ecol;
	uint target;
	ostringstream oss;
	char ply_name[__FILE_NAME_BUF_SIZE];
	char vert_name[__FILE_NAME_BUF_SIZE], face_name[__FILE_NAME_BUF_SIZE];
	
	getPatchPath(dir_path, grid_index, vert_name, face_name);

	// retrieve the simplified patch name
	if (dir_path) 
		oss << dir_path << hPathSeperator();
	oss << grid_index.i << "_" << grid_index.j << "_" << grid_index.k << "_simp.ply";
	stringToCstr(oss.str(), ply_name);

	if (!readPatch(vert_name, face_name, &ecol))
		return false;

	target = ((double) vert_count) / 
				((double) total_verts) * total_target + exterior_count;

	ecol.initialize();
	ecol.targetVert(target);

	if (!toPly(&ecol, ply_name))
		return false;

	return true;
}