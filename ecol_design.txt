author: ht
email : waytofall916@gmail.com

A Heuristic Reduced Edge Collapsing Approach Based on Spatial Division Patching for Simplification 
of Massive Meshes

基于空间分割分片与全局边收缩的启发式大规模网格简化

==============================$ collapse sequence file format $==================================

The collapsing sequence file looks like:

	#head
	#endian: LE/BE
	#comments: generated by reducing_iterative_edge_collapsing_based_on_spatial_division_patching
	#comments: generated at 02/06/2012 10:10
	#end
	<uint:sequential_id> <uint:patch_id> <uint:v1, uint:v2> <float:error> <float_3:new_vertex>
	<uint:sequential_id> <uint:patch_id> <uint:v1, uint:v2> <float:error> <float_3:new_vertex>
	<uint:sequential_id> <uint:patch_id> <uint:v1, uint:v2> <float:error> <float_3:new_vertex>
	...

This file is stored as binary file, so note that there are not any special 'EOF' character as in the 
text/ascii file, the END OF FILE occurred when the file come to be exhausted on the operating system 
disk file table.

Field specification:
<uint:sequential_id>	this can be viewed as the sequence denotion, and can be treated globally,
						when different patches of collapse sequence merges, for generating progressive
						meshes
<uint:patch_id>			denotes which patch the collapse belongs to
<uint:v1, uint:v2>		the ids of the two collapsed vertices, ignoring the order
<float:error>			the local error incurred by the collapsing operation, any mesurement can be 
						utilized such as the Quadric Error Metrics[M.Garland97], Progressive 
						Meshes[H.Hoppe96], or the volume preserving techniques by [Lindstrom&Turk98]
<float_3:new_vertex>	the representative vertex calculated for the two collapsed vertices

If you want to take the number of faces as the simplfication target, you can also add a field as 
<uint:faces_decimated>, however our approach target the simplification process based on the number 
vertices, so the fields above should be suffcient.

========================================$ data structures $======================================

$$ vertex $$

	/* out-of-core version */
	CollapsedVertex {
		uint: 		new_id		// the id after the collapse
		uint: 		output_id	// the id of the output model
		float_3:	new_vertex	// the new vertex after the collapse
	}

	/* in-core version */
	CollapsableVertex: INHERIT CollapsedVertex {
		// the linked collapsable edges in the heap, used for update
		collapsable_edge_list:	adjacent_collapsable_edges
		// use when decimated based on the face count, remove the face if needed
		face_list:	adjacent_faces
	}

	HierarchyVertex: INHERIT CollapsableVertex {
		face_list:	alter_faces		// faces need to alter when the vertex expand/contract
		face_list:	removed_faces	// faces need to remove/insert when the vertex expand/contract
	}

	QuadricVertex: INHERIT CollapsableVertex {
		float_10:	quadrics	// quadric error matrix
	}

	HierarchyQuadricVertex: INHERIT HierarchyVertex {
		float_10:	quadrics	// quadric error matrix
	}

Stored in continuous memory space with the index denoting the vertex index. This data structure 
can be used in both the in-core edge collapse algorithm and the out-of-core simplified mesh 
generation phase based on the collapsing sequence file.

=========================================$ algorithms $==========================================

$$ vertex invalidation & collasping sequence footprint $$

Note that when collapsing two vertices, the two vertices "MERGE" into one. Here we set one vertex
dead while keep another alive. The one alive is always the vertex with the LOWER index, and the 
'new_id' field the vertex with the HIGHER index is set to the LOWER index and thus deprecated afterwards. 
The 'new_vertex' field of the HIGHER vertex is set to the contracted new vertex. Due to that the dead 
HIGHER vertex will never be referred later, this is like a memoir for the collapse footprint. In 
case that after multi-step contractions, you can still restore the vertices of any collapsing step. 

The vertex is invalid if the new_id field is unequal to the index of the vertex, vice versa. Note 
that the 'new_vertex' field of the valid vertices is non-sense during the collapsing phase. Some 
operations should also be taken such that the removed/altered faces are marked. When you want to 
restore the collapsed new vertex of a specific collapse step when you've over-performed some, you 
need to look up backwards from the collapsing sequence and find most recent collapse of any valid 
vertices and look to the HIGHER vetex from the table for the 'new_vertex' field.

Consider the 'VertexCollapsing' table, which initially contains all the uncollapsed vertices:

		 new_id	 output_id
	______________________
	0	|	0	|	0
	1	|	1	|	1
	2	|	2	|	2
	3	|	3	|	3
		...
	7	|	7	|	7

Consider the collapsing sequence <4, 0> <5, 6> <5, 3> <0, 3> <1, 2>. First we collapse the two
vertices <4, 0>. The table altered to:

		 new_id	 output_id
	______________________
	0	|	0	|	0
	1	|	1	|	1
	2	|	2	|	2
	3	|	3	|	3
	4	|	0	|	4
		...
	7	|	7	|	7

Then we collapse <5, 6> the table altered to:

		 new_id	 output_id
	______________________
	0	|	0	|	0
	1	|	1	|	1
	2	|	2	|	2
	3	|	3	|	3
	4	|	0	|	4
	5	|	5	|	5
	6	|	5	|	6
	7	|	7	|	7
	
Then <5, 3> the table altered to:

		 new_id	 output_id
	______________________
	0	|	0	|	0
	1	|	1	|	1
	2	|	2	|	2
	3	|	3	|	3
	4	|	0	|	4
	5	|	3	|	5
	6	|	5	|	6
	7	|	7	|	7

After collapsing the whole sequence, the table altered to:

		 new_id	 output_id
	______________________
	0	|	0	|	0
	1	|	1	|	1
	2	|	1	|	2
	3	|	0	|	3
	4	|	0	|	4
	5	|	3	|	5
	6	|	5	|	6
	7	|	7	|	7

$$ output mesh generation $$

In order to retrieve the final contrated vertices id instead of the collapsing sequence footprint
stored currently, you should look up the the table top down. Whenever you come to an item in which
the 'new_id' field unequals to the index, update it to the 'new_id' field of the item with the 
index of the 'new_id' for the current item (this is like a previous node's previous node in a 
linked list, and note that the items in the table are in fact inversely linked to a list such 
that all the vertices in a cluster is linked together). After the table is scanned up, the 'new_id'
field happen to be the final contrated vertex id. 

Take the example above, after the scanning, the talbe looks like:

		 new_id	 output_id
	______________________
	0	|	0	|	0
	1	|	1	|	1
	2	|	1	|	2
	3	|	0	|	3
	4	|	0	|	4
	5	|	0	|	5
	6	|	0	|	6
	7	|	7	|	7

Based on the collapsing sequence, the verties should be contracted into three clusters, <0, 3, 4, 5, 6>,
<1, 2> and <7>. Given that the representative vertex for a cluster is the LOWEST, the table is just
what we want. Though the local faces of a specific patch have been contracted and updated, for the
out-of-core model which is divided into patches before the in-core iterative edge contraction is
performed, there are faces that belong to no patch and are part of the initial spatial division 
model. These faces should be updated after all the patches is contrated and the results merged,
the clustering information is used then.