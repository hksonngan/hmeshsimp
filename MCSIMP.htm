<body style = "padding: 30px">

When incrementally decimating an in-core part of the mesh, the decimation process adds out-of-core part of the mesh into the in-core boundary from time to time. This causes vertices and edges to be 'finalized' and leave the boundary while generating new 'unfinalized' boundaries. One key point for this process is how to know when a vertex is finalized. In [Streaming Meshes.Isenburg] there are references of the faces counted for the vertices which needs the whole mesh to be generated, our incrementally on-the-fly simplification process only needs to keep vertices whose amount are approximately one layer of the slices from the marching cubes algorithm on the boundary, and do not need to wail util the whole mesh generated to know when a vertex is finalized. <br/><br/>

We define six directions for travesing the cubes, which is left and right for the first dimension (for example, x dimension), front and back for the second dimension (for example, y dimension), up and down for the third dimension (for example, z dimension). Since the the marching cubes algorithm always traverses the whole cubes from one dimension first, than another dimension second, finally the other dimension third, and that the direction of the traversal for each dimension is always the same, we can assume that the traversal goes from left to the right for the first dimension, from front to the back for the second dimension, and from up to the down for the third dimension. When traversing a cube, we seperate the cube into eight categories: <br/><br/>

	normal <br/>
	right-most <br/>
	back-most <br/>
	down-most <br/>
	right-back-most <br/>
	right-down-most <br/>
	back-down-most <br/>
	right-back-down-most <br/><br/>

Since vertices generated by the marching cubes algorithm always reside on the edge of a cube, we can finalize the vertices on each edge of the cube based on the category of cube. <!-- We reserve an index for every cube and for every edge of cube, starting from zero in each dimension. The maximum index range of edge is always one bigger than cube in every dimenson. When adding triangles, we calculate the cube index of the triangles and finalize vertices on the corresponding edge based on the category of the cube, thus needing a hashmap whose key is the edge index and value is vertex. --><br/><br/>

One thing of the decimation is to guarantee that the unfinalized vertices aren't decimated so that edges containing such vertices (unfinalized edges) shouldn't be added to the global collapsable edge heap. Unfinalized edges should be added imediately after all the two vertices have been finalized. We need some technique different from what is used in QSlim [http://mgarland.org/software/qslim.html] to keep the edges in the heap unique. In our implementation, we just add the edge to the heap whenever one vertex of the edge is to be finalized and one vertex is already finalized. Since 'finalized' means that the edge will never be referred anymore, we can also apply any boundary contraints on it and never worry that it will be attached by some following triangles like in [Wu. A stream algorithm for the decimation of massive meshes]. This also decreases the buffer size of the uncollapsable boundary for the in-core part of the mesh, which is the key point for Streaming Meshes [Streaming Meshes.Isenburg]. <br/><br/>

Another nontrivial issue for implementation is that although edges with unfinalized vertices won't be collapsed during the decimation, they will still possibly be included in the collapse operation if vertices of the edge being collapsed are adjacent to some unfinalized vertices. The collapsed vertices need to update their adjacent edges thus may need to access or modify some unfinalized edges which are not in the global collapsalbe heap. We create an edge whenever one vertex of the edge is already in the in-core part and another is being added no matter whether the edge is collapasble (eg. finalized). We put such edge into some container instead of the global heap. As soon as the edge is finalized, it is tranferred into the global heap. For ease of retrieving, we choose the hashmap as the container when implementing with key being the two vertices' indices. <br/><br/>

</body>