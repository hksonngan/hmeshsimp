author: ht
email : waytofall916@gmail.com

A Heuristic Reduced Edge Collapsing Approach Based on Spatial Division Patching for Simplification 
of Massive Meshes

児噐腎寂蛍護蛍頭嚥畠蕉円辺抹議尼窟塀寄号庁利鯉酒晒

==============================$ Collapse Sequence File Format $==================================

The collapsing sequence file looks like:

	#head
	#endian: LE/BE
	#comments: generated by reducing_iterative_edge_collapsing_based_on_spatial_division_patching
	#comments: generated at 02/06/2012 10:10
	#end
	<uint:sequential_id> <uint:patch_id> <uint:v1, uint:v2> <float:error> <float_3:new_vertex>
	<uint:sequential_id> <uint:patch_id> <uint:v1, uint:v2> <float:error> <float_3:new_vertex>
	<uint:sequential_id> <uint:patch_id> <uint:v1, uint:v2> <float:error> <float_3:new_vertex>
	...

This file is stored as binary file, so note that there are not any special 'EOF' character as in the 
text/ascii file, the END OF FILE occurred when the file come to be exhausted on the operating system 
disk file table.

Field specification:
<uint:sequential_id>	this can be viewed as the sequence denotion, and can be treated globally,
						when different patches of collapse sequence merges, for generating progressive
						meshes
<uint:patch_id>			denotes which patch the collapse belongs to
<uint:v1, uint:v2>		the ids of the two collapsed vertices, ignoring the order
<float:error>			the local error incurred by the collapsing operation, any mesurement can be 
						utilized such as the Quadric Error Metrics[M.Garland97], Progressive 
						Meshes[H.Hoppe96], or the volume preserving techniques by [Lindstrom&Turk98]
<float_3:new_vertex>	the representative vertex calculated for the two collapsed vertices

If you want to take the number of faces as the simplfication target, you can also add a field as 
<uint:faces_decimated>, however our approach target the simplification process based on the number 
vertices, so the fields above should be suffcient.

========================================$ data structures $======================================

$$ vertex $$

	/* out-of-core version */
	CollapsedVertex {
		uint: 		new_id		// the id after the collapse
		uint: 		output_id	// the id of the output model
		float_3:	new_vertex	// the new vertex after the collapse
	}

	/* in-core version */
	CollapsableVertex: INHERIT CollapsedVertex {
		// the linked collapsable edges in the heap, used for update
		collapsable_edge_list:	adjacent_collapsable_edges
		// use when decimated based on the face count, remove the face if needed
		face_list:	adjacent_faces
	}

	HierarchyVertex: INHERIT CollapsableVertex {
		face_list:	alter_faces		// faces need to alter when the vertex expand/contract
		face_list:	removed_faces	// faces need to remove/insert when the vertex expand/contract
	}
	
Stored in continuous memory space with the index denoting the vertex index. This data structure 
can be used in both the in-core edge collapse algorithm and the out-of-core simplified mesh 
generation phase based on the collapsing sequence file.

The pairs stored in the priority queue should always point to the valid vertices, such that the
deprecated pairs should be freed. Note that the pair_heap only stores a pointer to the real struct, 
and the 'adjacent_col_pairs' field also stores a pointer to the real 'CollapsablePair' structure
located in operating system HEAP, so 'adjacent_col_pairs' field of different vertices in fact point 
to the same struct if they are the same. This is similar to 'adjacent_faces' field which storing
the index of the face in the faces array.

=========================================$ algorithms $==========================================

$$ Vertex Invalidation & Collasping Sequence Footprint $$

Note that when collapsing two vertices, the two vertices "MERGE" into one. Here we set one vertex
dead while keep another alive. The one alive is always the vertex with the LOWER index, and the 
'new_id' field the vertex with the HIGHER index is set to the LOWER index and thus deprecated afterwards. 
The 'new_vertex' field of the HIGHER vertex is set to the contracted new vertex. Due to that the dead 
HIGHER vertex will never be referred later, this is like a memoir for the collapse footprint. In 
case that after multi-step contractions, you can still restore the vertices of any collapsing step. 

The vertex is invalid if the new_id field is unequal to the index of the vertex, vice versa. Note 
that the 'new_vertex' field of the valid vertices is non-sense during the collapsing phase. Some 
operations should also be taken such that the removed/altered faces are marked. When you want to 
restore the collapsed new vertex of a specific collapse step when you've over-performed some, you 
need to look up backwards from the collapsing sequence and find most recent collapse of any valid 
vertices and look to the HIGHER vetex from the table for the 'new_vertex' field.

Consider the 'VertexCollapsing' table, which initially contains all the uncollapsed vertices:

		 new_id	 output_id
	！！！！！！！！！！！！！！！！！！！！！！
	0	|	0	|	0
	1	|	1	|	1
	2	|	2	|	2
	3	|	3	|	3
		...
	7	|	7	|	7

Consider the collapsing sequence <4, 0> <5, 6> <5, 3> <0, 3> <1, 2>. First we collapse the two
vertices <4, 0>. The table altered to:

		 new_id	 output_id
	！！！！！！！！！！！！！！！！！！！！！！
	0	|	0	|	0
	1	|	1	|	1
	2	|	2	|	2
	3	|	3	|	3
	4	|	0	|	4
		...
	7	|	7	|	7

Then we collapse <5, 6> the table altered to:

		 new_id	 output_id
	！！！！！！！！！！！！！！！！！！！！！！
	0	|	0	|	0
	1	|	1	|	1
	2	|	2	|	2
	3	|	3	|	3
	4	|	0	|	4
	5	|	5	|	5
	6	|	5	|	6
	7	|	7	|	7
	
Then <5, 3> the table altered to:

		 new_id	 output_id
	！！！！！！！！！！！！！！！！！！！！！！
	0	|	0	|	0
	1	|	1	|	1
	2	|	2	|	2
	3	|	3	|	3
	4	|	0	|	4
	5	|	3	|	5
	6	|	5	|	6
	7	|	7	|	7

After collapsing the whole sequence, the table altered to:

		 new_id	 output_id
	！！！！！！！！！！！！！！！！！！！！！！
	0	|	0	|	0
	1	|	1	|	1
	2	|	1	|	2
	3	|	0	|	3
	4	|	0	|	4
	5	|	3	|	5
	6	|	5	|	6
	7	|	7	|	7

$$ Output Mesh Generation $$

In order to retrieve the final contrated vertices id instead of the collapsing sequence footprint
stored currently, you should look up the the table top down. Whenever you come to an item in which
the 'new_id' field unequals to the index, update it to the 'new_id' field of the item with the 
index of the 'new_id' for the current item (this is like a previous node's previous node in a 
linked list, and note that the items in the table are in fact inversely linked to a list such 
that all the vertices in a cluster is linked together). After the table is scanned up, the 'new_id'
field happen to be the final contrated vertex id. 

Take the example above, after the scanning, the table looks like:

		 new_id	 output_id
	！！！！！！！！！！！！！！！！！！！！！！
	0	|	0	|	0
	1	|	1	|	1
	2	|	1	|	2
	3	|	0	|	3
	4	|	0	|	4
	5	|	0	|	5
	6	|	0	|	6
	7	|	7	|	7

Based on the collapsing sequence, the verties should be contracted into three clusters, <0, 3, 4, 5, 6>,
<1, 2> and <7>. Given that the representative vertex for a cluster is the LOWEST, the table is just
what we want. Though the local faces of a specific patch have been contracted and updated, for the
out-of-core model which is divided into patches before the in-core iterative edge contraction is
performed, there are faces that belong to no patch and are part of the initial spatial division 
model. These faces should be updated after all the patches is contrated and the results merged,
the clustering information is used then.

$$ Collapsing Vertices Pair $$
 
$$$ Collapsable Pair Array Merge $$$

When merging the the two pair arrays, we first alter the vertex with the HIGHER index to the LOWER index.
This may cause some duplications, invalidations and order-broken for pairs. We first fix the broken-order
pairs and conduct the merge. During merging, we first perform sorting for non-duplicated result. When 
sorting the pair_arr, the array is sorted based on the two vertices indices. So there may result in two 
types of equals (equal elements reside continuously in the sorted array), one is the value equal, which 
means that they point to different structs which have the same value in vert1, vert2 field, one is pointer 
equal which means the two different pointer points to the same struct. So these may need some special 
treatment when merging.

The compare function when sorting the vertices pair is: 

	bool pair_comp(CollapsablePair *pair1, const CollapsablePair *pair2)

		return vert1 < pair.vert1 || 
			vert1 == pair.vert1 && vert2 < pair.vert2;

We simply returns the strict weak order of the sequence <vert1, vert2> which must guarantee that vert1 < 
vert2, while vert1 field act as the more significant one. While merging, we assume that the two arrays 
have no duplications and the only the merged arrays have duplications. This is true because we carefully 
maintain the 'adjacent_col_pairs' field to guarantee that it's unique. But if it's not, the compare 
function should be like:

	bool pair_comp(CollapsablePair *pair1, const CollapsablePair *pair2)

			return vert1 < pair.vert1 || 
				vert1 == pair.vert1 && vert2 < pair.vert2 || 
				pair1 < pair2;
				
In case that two different pair pointer pointing to different structs in the same array while having
the same value, and we should also add some more trivial special treatment in order to keep the array
clean and right. So in fact, when collapsing, there are two kinds of invalid pairs, one is invalidates
by vert1 == vert2, one is invalidates by duiplicates to another pair. This is the same case when 
collapsing faces.
